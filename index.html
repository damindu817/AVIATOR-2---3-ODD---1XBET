<!DOCTYPE html>
<html lang="si">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Xtreme Aviator Predictor</title>
<link rel="icon" href="https://upload.wikimedia.org/wikipedia/commons/3/3c/Aviator_helmet_icon.png">
<style>
/* [Previous CSS remains the same until .signal-circle] */

.signal-circle {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 2;
  background: radial-gradient(circle at center, #111 0%, #000 100%);
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  border: 3px solid rgba(255, 255, 255, 0.3);
  transition: all 0.5s ease;
  overflow: hidden;
}

/* NEW Ripple Effect - From Outline */
.ripple-outline {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  pointer-events: none;
  z-index: 1;
}

.ripple-outline::before {
  content: '';
  position: absolute;
  top: -3px;
  left: -3px;
  right: -3px;
  bottom: -3px;
  border-radius: 50%;
  border: 3px solid transparent;
  animation: rippleOutline 2s ease-out infinite;
  opacity: 0;
}

.signal-circle.purple .ripple-outline::before {
  border-color: #9c27b0;
}

.signal-circle.red .ripple-outline::before {
  border-color: #f44336;
}

.signal-circle.green .ripple-outline::before {
  border-color: #4caf50;
}

@keyframes rippleOutline {
  0% {
    transform: scale(1);
    opacity: 0.8;
  }
  100% {
    transform: scale(1.5);
    opacity: 0;
  }
}

/* [Rest of CSS remains the same] */
</style>
</head>

<body>
<!-- [Previous HTML remains the same] -->

<script>
// [Previous JavaScript remains the same until ripple functions]

function createRippleEffect(colorClass) {
  const circle = document.getElementById('signalCircle');
  if (!circle) return;
  
  // Remove existing ripple outline
  const existingRipple = circle.querySelector('.ripple-outline');
  if (existingRipple) {
    existingRipple.remove();
  }
  
  // Create new ripple outline
  const rippleOutline = document.createElement('div');
  rippleOutline.className = 'ripple-outline';
  circle.appendChild(rippleOutline);
}

function stopRippleEffect() {
  const circle = document.getElementById('signalCircle');
  if (!circle) return;
  
  const rippleOutline = circle.querySelector('.ripple-outline');
  if (rippleOutline) {
    rippleOutline.remove();
  }
}

// [Modify the updateSignalDisplay function where ripple effects are called]
function updateSignalDisplay() {
  const now = new Date();
  const circle = document.getElementById('signalCircle');
  const odd = document.getElementById('oddValue');
  const beep = document.getElementById('beepSound');

  if (loadingPhase) {
    // [Previous loading phase code]
    stopRippleEffect();
    return;
  }

  if (signals.length === 0) {
    // [Previous completed signal code]
    circle.className = 'signal-circle green';
    createRippleEffect('green');
    return;
  }

  if (loadingNextSignal) {
    // [Previous loading next signal code]
    stopRippleEffect();
    return;
  }

  if (currentIndex >= signals.length) {
    // [Previous all signals completed code]
    circle.className = 'signal-circle green';
    createRippleEffect('green');
    return;
  }

  const signal = signals[currentIndex];
  const signalTime = new Date(`${signal.date}T${signal.time}`);
  const endTime = new Date(signalTime.getTime() + 60000);

  if (now < signalTime) {
    // [Previous upcoming signal code]
    circle.className = 'signal-circle purple';
    createRippleEffect('purple');
    beepPlayed = false;
    return;
  }

  if (now >= signalTime && now < endTime) {
    // [Previous active signal code]
    circle.className = 'signal-circle red';
    createRippleEffect('red');
    if (!beepPlayed) {
      beep.play();
      beepPlayed = true;
    }
    return;
  }

  if (now >= endTime) {
    // [Previous signal ended code]
    stopRippleEffect();
  }
}

// [Rest of JavaScript remains the same]
</script>
</body>
</html>